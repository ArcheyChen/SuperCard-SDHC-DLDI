#include "new_scsdio.h"
#include <cstdio>

extern bool isSDHC;

uint8_t _SD_CRC7(uint8_t *pBuf, int len);
void WriteSector(u16 *buff,u32 sector,u32 writenum)
{
    u32 crc16[5];   
    sc_mode(en_sdcard);
    sc_sdcard_reset();
    // auto param = isSDHC ? sector : (sector << 9);
    auto param = (sector << 9);
	SDCommand(25,0,param); 
	get_resp_drop();
	send_clk(0x10); 
    for (u32 j=0;j<writenum ; j++)
	{
		sd_crc16_s((u16*)((u32)buff+j*512),512,(u16*)crc16);
		sd_data_write((u16*)((u32)buff+j*512),(u16*)crc16);
		send_clk(0x10); 
	}
	SDCommand(12,0,0); 
	get_resp_drop();
	send_clk(0x10);
    vu16* wait_busy = (vu16*)sd_dataadd;
	while(((*wait_busy) &0x0100)==0);
    return;
}

void ReadSector(uint16_t *buff, uint32_t sector, uint8_t readnum) {

    // First SDCommand call - setup command
    SDCommand(0x12, 0, sector << 9); // R0 = 0x12, R1 = 0, R2 as calculated above

    uint8_t i = 0;
    while (i < readnum) {
        sd_data_read_s((uint16_t*)(buff)); // Add R6, left shifted by 9, to R4 before casting
        buff += 512/2;
        i++;
    }

    // Final sequence of commands after reading sectors
    SDCommand(0xC, 0, 0); // Command to presumably stop reading
    get_resp(); // Get response from SD card
    send_clk(0x10); // Send clock signal

    // There's an implicit return here in the assembly, which cleans up the stack and returns
    // This is handled automatically in C by reaching the end of the function
}


#define BUSY_WAIT_TIMEOUT 500000
#define SCSD_STS_BUSY			0x100


void sd_data_write(u16 *buff,u16* crc16buff) {
    vu16* const wait_busy = (vu16*)sd_dataadd;
    vu16* const data_write_u16 = (vu16*)sd_dataadd;
    vu32* const data_write_u32 = (vu32*)sd_dataadd;
	while(!((*wait_busy) &0x0100));//Note:两边的等待是不一致的
    *wait_busy;

    *data_write_u16 = 0;//start bit

    auto writeU16 = [data_write_u32](uint32_t data) {
        data |= (data << 20);
        *data_write_u32 = data;
        *data_write_u32 = (data >> 8);
    };
    for(int i=0;i<512;i+=2){
        writeU16(*buff++);
    }
    if(crc16buff){
        for(int i=0;i<4;i++){
            writeU16(*crc16buff++);
        }
    }
    *data_write_u16 = 0xFF;//end bit
	while(((*wait_busy) &0x0100));//Note:这个部分与上个部分是不一样的
}
void  sc_mode(u16 mode) {
   // if(currentMode == mode)
   //    return;
	vu16 *sc_mode_addr = (vu16*)0x09FFFFFE;
	*sc_mode_addr = 0xA55A ;
	*sc_mode_addr = 0xA55A ;
	*sc_mode_addr = mode ;
	*sc_mode_addr = mode ;
   // currentMode = mode;
} 

void sc_sdcard_reset(void){
    vu16* reset_addr = (vu16*)sd_reset;
    *reset_addr = 0xFFFF;
}

void send_clk(u32 num){
    vu16* cmd_addr = (vu16*)sd_comadd;
    while(num--){
        *cmd_addr;
    }
}

#define REG_SCSD_CMD	(*(vu16*)(0x09800000))
void SDCommand (u8 command, uint8_t num, u32 argument) {
	u8 databuff[6];
	u8 *tempDataPtr = databuff;

	*tempDataPtr++ = command | 0x40;
	*tempDataPtr++ = argument>>24;
	*tempDataPtr++ = argument>>16;
	*tempDataPtr++ = argument>>8;
	*tempDataPtr++ = argument;
	*tempDataPtr = _SD_CRC7 (databuff, 5);


	while (((REG_SCSD_CMD & 0x01) == 0));
		
	REG_SCSD_CMD;

	tempDataPtr = databuff;
	volatile uint32_t* send_command_addr = (volatile uint32_t*)(0x09800000); // 假设sd_comadd也是数据写入地址

	int length = 6;
	while (length--) {
		uint32_t data = *tempDataPtr++;
        data = data | (data << 17);
        *send_command_addr = data; 
        *send_command_addr = data<<2; 
        *send_command_addr = data<<4; 
        *send_command_addr = data<<6; 
		//sd_dataadd[0] ~ [3]至少目前证明都是镜像的，可以随便用，可以用stmia来加速
		//本质上是将U16的写合并成U32的写
	}
}
void get_resp_drop() {
	int byteNum = 6 + 1;//6resp + 8 clocks
	
	// Wait for the card to be non-busy
	vu16* const cmd_addr_u16 = (vu16*)(0x09800000);
	vu32* const cmd_addr_u32 = (vu32*)(0x09800000);
	while ((((*cmd_addr_u16) & 0x01) != 0));
    //实际上，当跳出这个循环的时候，已经读了一个bit了，后续会多读一个bit，但是这是抛弃的rsp,因此多读一个bit也就是多一个时钟周期罢了
	while(byteNum--){
        *cmd_addr_u32;
        *cmd_addr_u32;
        *cmd_addr_u32;
        *cmd_addr_u32;
    }
}

const uint8_t crc_lut[]=
{0x0,0x12,0x24,0x36,0x48,0x5A,0x6C,0x7E,0x90,0x82,0xB4,0xA6,0xD8,0xCA,0xFC,0xEE,
0x32,0x20,0x16,0x4,0x7A,0x68,0x5E,0x4C,0xA2,0xB0,0x86,0x94,0xEA,0xF8,0xCE,0xDC,
0x64,0x76,0x40,0x52,0x2C,0x3E,0x8,0x1A,0xF4,0xE6,0xD0,0xC2,0xBC,0xAE,0x98,0x8A,
0x56,0x44,0x72,0x60,0x1E,0xC,0x3A,0x28,0xC6,0xD4,0xE2,0xF0,0x8E,0x9C,0xAA,0xB8,
0xC8,0xDA,0xEC,0xFE,0x80,0x92,0xA4,0xB6,0x58,0x4A,0x7C,0x6E,0x10,0x2,0x34,0x26,
0xFA,0xE8,0xDE,0xCC,0xB2,0xA0,0x96,0x84,0x6A,0x78,0x4E,0x5C,0x22,0x30,0x6,0x14,
0xAC,0xBE,0x88,0x9A,0xE4,0xF6,0xC0,0xD2,0x3C,0x2E,0x18,0xA,0x74,0x66,0x50,0x42,
0x9E,0x8C,0xBA,0xA8,0xD6,0xC4,0xF2,0xE0,0xE,0x1C,0x2A,0x38,0x46,0x54,0x62,0x70,
0x82,0x90,0xA6,0xB4,0xCA,0xD8,0xEE,0xFC,0x12,0x0,0x36,0x24,0x5A,0x48,0x7E,0x6C,
0xB0,0xA2,0x94,0x86,0xF8,0xEA,0xDC,0xCE,0x20,0x32,0x4,0x16,0x68,0x7A,0x4C,0x5E,
0xE6,0xF4,0xC2,0xD0,0xAE,0xBC,0x8A,0x98,0x76,0x64,0x52,0x40,0x3E,0x2C,0x1A,0x8,
0xD4,0xC6,0xF0,0xE2,0x9C,0x8E,0xB8,0xAA,0x44,0x56,0x60,0x72,0xC,0x1E,0x28,0x3A,
0x4A,0x58,0x6E,0x7C,0x2,0x10,0x26,0x34,0xDA,0xC8,0xFE,0xEC,0x92,0x80,0xB6,0xA4,
0x78,0x6A,0x5C,0x4E,0x30,0x22,0x14,0x6,0xE8,0xFA,0xCC,0xDE,0xA0,0xB2,0x84,0x96,
0x2E,0x3C,0xA,0x18,0x66,0x74,0x42,0x50,0xBE,0xAC,0x9A,0x88,0xF6,0xE4,0xD2,0xC0,
0x1C,0xE,0x38,0x2A,0x54,0x46,0x70,0x62,0x8C,0x9E,0xA8,0xBA,0xC4,0xD6,0xE0,0xF2};

inline uint8_t CRC7_one(uint8_t crcIn, uint8_t data) {
	crcIn ^= data;
	return crc_lut[crcIn];
}
uint8_t _SD_CRC7(uint8_t *pBuf, int len) {
	uint8_t crc = 0;
	while (len--) crc = CRC7_one(crc,*pBuf++);
    crc |= 1;
	return crc;
}